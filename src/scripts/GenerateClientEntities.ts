import path from 'path'
import fs from 'fs'
import logger from '../../src/utils/logger'

const serverRoot = path.join(__dirname, '../..')

const inputFile = path.join(serverRoot, 'build/typedoc.json')

const typesContent = fs.readFileSync(inputFile, 'utf8')
const types = JSON.parse(typesContent)

const outputPath = path.join(serverRoot, 'build/UnityModels')
fs.mkdir(outputPath, { recursive: true }, (err) => {
  if (err) throw err
})

const excludeModels = ['EntityBase']

const buildtime = new Date()
const buildstring = `${buildtime.toLocaleDateString()} ${buildtime.toLocaleTimeString()}`
const header = `// Autogenerated ${buildstring}`

const namespace = 'Openworld.Models'

const toStringMethod = `public override string ToString(){
      return UnityEngine.JsonUtility.ToJson (this, true);
    }`

const entityTemplate = `${header}
using System;

namespace ${namespace}
{
  [Serializable]
  public class {modelName}{extends}
  {
{fields}

    ${toStringMethod} 
  }
}`

const fieldTemplate = `    public {type} {fieldname};`

/**
 * @description Convert data types from typescript to c#
 *
 * @param type the typescript data type to convert
 * @returns the equivalent c# data type
 */
function getTypeString(type) {
  const typeMap = {
    uuid: 'string',
    datetime: 'string',
    string: 'string',
    number: 'int',
    Date: 'DateTime',
    boolean: 'bool'
  }

  if (type.type == 'array') {
    // return typeMap[type.elementType.name] + '[]'
    return getTypeString(type.elementType) + '[]'
  }
  let unionString
  let ret
  switch (type.type) {
    case 'intrinsic':
      ret = typeMap[type.name]
      break
    case 'reference':
      ret = typeMap[type.name] || type.name
      break
    case 'union':
      //get the least specific type
      unionString = type.types.map((x) => x.name).join('|')
      if (unionString == 'string|number' || unionString == 'number|string') {
        ret = typeMap.string
      } else {
        logger.warn('unsupported union type: ' + type.types.map((x) => x.name).join('|'))
        ret = '<undetermined union>'
      }
      break
    default:
      ret = undefined
      break
  }
  if (!ret) {
    logger.warn(`undefined type: ${type.name}`)
  }
  return ret
}

function getFlattenedExtends(branch: any) {
  const extend = []

  if (branch.extendedTypes) {
    for (const item in branch.extendedTypes) {
      const ext = branch.extendedTypes[item]
      if (ext.type == 'reference' && !excludeModels.includes(ext.name)) {
        extend.push(ext.name)
      }
    }
  }
  return extend
}

function getObjectsOfKindFromEach(branch: any, kind: string) {
  let ret = {}
  for (const item in branch.children) {
    const childItem = branch.children[item]
    const children = getObjectsOfKind(childItem, kind)
    ret = { ...ret, ...children }
  }
  return ret
}

function getObjectsOfKind(branch: any, kind: string) {
  const ret = {}
  for (const item in branch.children) {
    const child = branch.children[item]
    if (child.kindString == kind) {
      ret[child.name] = child
    }
  }
  return ret
}

function getEnumItems(branch: any) {
  const members = getObjectsOfKind(branch, 'Enumeration member')
  const items = {}
  for (const item in members) {
    const member = members[item]
    items[member.defaultValue] = member.name
  }
  return items
}

function getColumns(branch: any) {
  const rawColumns = getObjectsOfKind(branch, 'Property')
  const columns = {}
  for (const item in rawColumns) {
    const field = rawColumns[item]
    if (!field.inheritedFrom) {
      columns[field.name] = getTypeString(field.type)
    }
  }
  return columns
}

const modules = { children: getObjectsOfKind(types, 'Module') }

const typeMap = {
  interfaces: getObjectsOfKindFromEach(modules, 'Interface'),
  models: getObjectsOfKindFromEach(modules, 'Class'),
  enums: getObjectsOfKindFromEach(modules, 'Enumeration')
}

for (const modelName in typeMap.models) {
  if (!excludeModels.includes(modelName)) {
    logger.debug('processing ' + modelName)
    const model = typeMap.models[modelName]
    model.flattenedExtends = getFlattenedExtends(model)
    model.columns = getColumns(model)
    const fields = []
    for (const fieldName in model.columns) {
      const type = model.columns[fieldName]
      fields.push(fieldTemplate.replace('{type}', type).replace('{fieldname}', fieldName))
    }
    const output = entityTemplate
      .replace('{modelName}', modelName)
      .replace('{extends}', model.flattenedExtends.length > 0 ? ` : ${model.flattenedExtends.join(',')}` : '')
      .replace('{fields}', fields.join('\n'))
    if (output.includes('undefined')) {
      logger.warn(`undefined in ${modelName}: ${output}`)
    }
    writeFile(modelName, output)
  }
}

for (const enumName in typeMap.enums) {
  if (!excludeModels.includes(enumName)) {
    logger.debug('processing enum ' + enumName)
    const model = typeMap.enums[enumName]
    const enumItems = getEnumItems(model)
    const members = []
    for (const item in enumItems) {
      members.push(`${enumItems[item]} = ${item}`)
    }

    const output = `namespace Openworld.Models
{
  public enum ${enumName}
  {
    ${members.join(',\n    ')}
  }
}`
    writeFile(enumName, output)
  }
}

function writeFile(name: string, output: string) {
  const outFile = path.join(outputPath, `${name}`)
  fs.writeFileSync(outFile, output)
  logger.info(`File written: ${outFile}`)
}
